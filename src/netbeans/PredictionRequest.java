package generador.de.modelos;
// Generated 12-mar-2019 17:18:59 by Hibernate Tools 4.3.1


import java.util.Date;
import java.util.HashSet;
import java.util.Set;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import static javax.persistence.GenerationType.IDENTITY;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;

/**
 * PredictionRequest generated by hbm2java
 */
@Entity
@Table(name="prediction_request"
    ,catalog="metaserver2"
)
public class PredictionRequest  implements java.io.Serializable {


     private Integer id;
     private PrivatePredictionEvaluation privatePredictionEvaluation;
     private ScheduleRequest scheduleRequest;
     private Server server;
     private ServerVersion serverVersion;
     private Task task;
     private Integer numberOfDocuments;
     private Integer numberOfDocumentsRecived;
     private Integer numberOfPredictions;
     private Integer numberOfResponses;
     private Integer numberOfTypes;
     private Integer unreachableCount;
     private Boolean isExpired;
     private Boolean isEnd;
     private Boolean isSended;
     private Boolean isPrivate;
     private Boolean endsWithError;
     private Boolean toEvaluate;
     private String parameters;
     private Date created;
     private Date recived;
     private Integer recivedInt;
     private Date expired;
     private Date sended;
     private Integer sendedInt;
     private String formatType;
     private Float totalTime;
     private Float avgTimePerDocument;
     private Float avgTimePerPrediction;
     private Boolean hasException;
     private String exception;
     private String description;
     private Integer totalAnnotatedWords;
     private String hash;
     private Integer documentsBytes;
     private boolean lock;
     private Set<PredictionResponse> predictionResponses = new HashSet<PredictionResponse>(0);
     private Set<PrivatePrediction> privatePredictions = new HashSet<PrivatePrediction>(0);
     private Set<Prediction> predictions = new HashSet<Prediction>(0);

    public PredictionRequest() {
    }

	
    public PredictionRequest(Server server, ServerVersion serverVersion, boolean lock) {
        this.server = server;
        this.serverVersion = serverVersion;
        this.lock = lock;
    }
    public PredictionRequest(PrivatePredictionEvaluation privatePredictionEvaluation, ScheduleRequest scheduleRequest, Server server, ServerVersion serverVersion, Task task, Integer numberOfDocuments, Integer numberOfDocumentsRecived, Integer numberOfPredictions, Integer numberOfResponses, Integer numberOfTypes, Integer unreachableCount, Boolean isExpired, Boolean isEnd, Boolean isSended, Boolean isPrivate, Boolean endsWithError, Boolean toEvaluate, String parameters, Date created, Date recived, Integer recivedInt, Date expired, Date sended, Integer sendedInt, String formatType, Float totalTime, Float avgTimePerDocument, Float avgTimePerPrediction, Boolean hasException, String exception, String description, Integer totalAnnotatedWords, String hash, Integer documentsBytes, boolean lock, Set<PredictionResponse> predictionResponses, Set<PrivatePrediction> privatePredictions, Set<Prediction> predictions) {
       this.privatePredictionEvaluation = privatePredictionEvaluation;
       this.scheduleRequest = scheduleRequest;
       this.server = server;
       this.serverVersion = serverVersion;
       this.task = task;
       this.numberOfDocuments = numberOfDocuments;
       this.numberOfDocumentsRecived = numberOfDocumentsRecived;
       this.numberOfPredictions = numberOfPredictions;
       this.numberOfResponses = numberOfResponses;
       this.numberOfTypes = numberOfTypes;
       this.unreachableCount = unreachableCount;
       this.isExpired = isExpired;
       this.isEnd = isEnd;
       this.isSended = isSended;
       this.isPrivate = isPrivate;
       this.endsWithError = endsWithError;
       this.toEvaluate = toEvaluate;
       this.parameters = parameters;
       this.created = created;
       this.recived = recived;
       this.recivedInt = recivedInt;
       this.expired = expired;
       this.sended = sended;
       this.sendedInt = sendedInt;
       this.formatType = formatType;
       this.totalTime = totalTime;
       this.avgTimePerDocument = avgTimePerDocument;
       this.avgTimePerPrediction = avgTimePerPrediction;
       this.hasException = hasException;
       this.exception = exception;
       this.description = description;
       this.totalAnnotatedWords = totalAnnotatedWords;
       this.hash = hash;
       this.documentsBytes = documentsBytes;
       this.lock = lock;
       this.predictionResponses = predictionResponses;
       this.privatePredictions = privatePredictions;
       this.predictions = predictions;
    }
   
     @Id @GeneratedValue(strategy=IDENTITY)

    
    @Column(name="id", unique=true, nullable=false)
    public Integer getId() {
        return this.id;
    }
    
    public void setId(Integer id) {
        this.id = id;
    }

@ManyToOne(fetch=FetchType.LAZY)
    @JoinColumn(name="private_prediction_evaluation_id")
    public PrivatePredictionEvaluation getPrivatePredictionEvaluation() {
        return this.privatePredictionEvaluation;
    }
    
    public void setPrivatePredictionEvaluation(PrivatePredictionEvaluation privatePredictionEvaluation) {
        this.privatePredictionEvaluation = privatePredictionEvaluation;
    }

@ManyToOne(fetch=FetchType.LAZY)
    @JoinColumn(name="schedule_request_id")
    public ScheduleRequest getScheduleRequest() {
        return this.scheduleRequest;
    }
    
    public void setScheduleRequest(ScheduleRequest scheduleRequest) {
        this.scheduleRequest = scheduleRequest;
    }

@ManyToOne(fetch=FetchType.LAZY)
    @JoinColumn(name="server_id", nullable=false)
    public Server getServer() {
        return this.server;
    }
    
    public void setServer(Server server) {
        this.server = server;
    }

@ManyToOne(fetch=FetchType.LAZY)
    @JoinColumn(name="server_version_id", nullable=false)
    public ServerVersion getServerVersion() {
        return this.serverVersion;
    }
    
    public void setServerVersion(ServerVersion serverVersion) {
        this.serverVersion = serverVersion;
    }

@ManyToOne(fetch=FetchType.LAZY)
    @JoinColumn(name="task_id")
    public Task getTask() {
        return this.task;
    }
    
    public void setTask(Task task) {
        this.task = task;
    }

    
    @Column(name="number_of_documents")
    public Integer getNumberOfDocuments() {
        return this.numberOfDocuments;
    }
    
    public void setNumberOfDocuments(Integer numberOfDocuments) {
        this.numberOfDocuments = numberOfDocuments;
    }

    
    @Column(name="number_of_documents_recived")
    public Integer getNumberOfDocumentsRecived() {
        return this.numberOfDocumentsRecived;
    }
    
    public void setNumberOfDocumentsRecived(Integer numberOfDocumentsRecived) {
        this.numberOfDocumentsRecived = numberOfDocumentsRecived;
    }

    
    @Column(name="number_of_predictions")
    public Integer getNumberOfPredictions() {
        return this.numberOfPredictions;
    }
    
    public void setNumberOfPredictions(Integer numberOfPredictions) {
        this.numberOfPredictions = numberOfPredictions;
    }

    
    @Column(name="number_of_responses")
    public Integer getNumberOfResponses() {
        return this.numberOfResponses;
    }
    
    public void setNumberOfResponses(Integer numberOfResponses) {
        this.numberOfResponses = numberOfResponses;
    }

    
    @Column(name="number_of_types")
    public Integer getNumberOfTypes() {
        return this.numberOfTypes;
    }
    
    public void setNumberOfTypes(Integer numberOfTypes) {
        this.numberOfTypes = numberOfTypes;
    }

    
    @Column(name="unreachable_count")
    public Integer getUnreachableCount() {
        return this.unreachableCount;
    }
    
    public void setUnreachableCount(Integer unreachableCount) {
        this.unreachableCount = unreachableCount;
    }

    
    @Column(name="is_expired")
    public Boolean getIsExpired() {
        return this.isExpired;
    }
    
    public void setIsExpired(Boolean isExpired) {
        this.isExpired = isExpired;
    }

    
    @Column(name="is_end")
    public Boolean getIsEnd() {
        return this.isEnd;
    }
    
    public void setIsEnd(Boolean isEnd) {
        this.isEnd = isEnd;
    }

    
    @Column(name="is_sended")
    public Boolean getIsSended() {
        return this.isSended;
    }
    
    public void setIsSended(Boolean isSended) {
        this.isSended = isSended;
    }

    
    @Column(name="is_private")
    public Boolean getIsPrivate() {
        return this.isPrivate;
    }
    
    public void setIsPrivate(Boolean isPrivate) {
        this.isPrivate = isPrivate;
    }

    
    @Column(name="ends_with_error")
    public Boolean getEndsWithError() {
        return this.endsWithError;
    }
    
    public void setEndsWithError(Boolean endsWithError) {
        this.endsWithError = endsWithError;
    }

    
    @Column(name="to_evaluate")
    public Boolean getToEvaluate() {
        return this.toEvaluate;
    }
    
    public void setToEvaluate(Boolean toEvaluate) {
        this.toEvaluate = toEvaluate;
    }

    
    @Column(name="parameters")
    public String getParameters() {
        return this.parameters;
    }
    
    public void setParameters(String parameters) {
        this.parameters = parameters;
    }

    @Temporal(TemporalType.TIMESTAMP)
    @Column(name="created", length=19)
    public Date getCreated() {
        return this.created;
    }
    
    public void setCreated(Date created) {
        this.created = created;
    }

    @Temporal(TemporalType.TIMESTAMP)
    @Column(name="recived", length=19)
    public Date getRecived() {
        return this.recived;
    }
    
    public void setRecived(Date recived) {
        this.recived = recived;
    }

    
    @Column(name="recived_int")
    public Integer getRecivedInt() {
        return this.recivedInt;
    }
    
    public void setRecivedInt(Integer recivedInt) {
        this.recivedInt = recivedInt;
    }

    @Temporal(TemporalType.TIMESTAMP)
    @Column(name="expired", length=19)
    public Date getExpired() {
        return this.expired;
    }
    
    public void setExpired(Date expired) {
        this.expired = expired;
    }

    @Temporal(TemporalType.TIMESTAMP)
    @Column(name="sended", length=19)
    public Date getSended() {
        return this.sended;
    }
    
    public void setSended(Date sended) {
        this.sended = sended;
    }

    
    @Column(name="sended_int")
    public Integer getSendedInt() {
        return this.sendedInt;
    }
    
    public void setSendedInt(Integer sendedInt) {
        this.sendedInt = sendedInt;
    }

    
    @Column(name="format_type", length=50)
    public String getFormatType() {
        return this.formatType;
    }
    
    public void setFormatType(String formatType) {
        this.formatType = formatType;
    }

    
    @Column(name="total_time", precision=12, scale=0)
    public Float getTotalTime() {
        return this.totalTime;
    }
    
    public void setTotalTime(Float totalTime) {
        this.totalTime = totalTime;
    }

    
    @Column(name="avg_time_per_document", precision=12, scale=0)
    public Float getAvgTimePerDocument() {
        return this.avgTimePerDocument;
    }
    
    public void setAvgTimePerDocument(Float avgTimePerDocument) {
        this.avgTimePerDocument = avgTimePerDocument;
    }

    
    @Column(name="avg_time_per_prediction", precision=12, scale=0)
    public Float getAvgTimePerPrediction() {
        return this.avgTimePerPrediction;
    }
    
    public void setAvgTimePerPrediction(Float avgTimePerPrediction) {
        this.avgTimePerPrediction = avgTimePerPrediction;
    }

    
    @Column(name="has_exception")
    public Boolean getHasException() {
        return this.hasException;
    }
    
    public void setHasException(Boolean hasException) {
        this.hasException = hasException;
    }

    
    @Column(name="exception", length=65535)
    public String getException() {
        return this.exception;
    }
    
    public void setException(String exception) {
        this.exception = exception;
    }

    
    @Column(name="description", length=65535)
    public String getDescription() {
        return this.description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }

    
    @Column(name="total_annotated_words")
    public Integer getTotalAnnotatedWords() {
        return this.totalAnnotatedWords;
    }
    
    public void setTotalAnnotatedWords(Integer totalAnnotatedWords) {
        this.totalAnnotatedWords = totalAnnotatedWords;
    }

    
    @Column(name="hash", length=40)
    public String getHash() {
        return this.hash;
    }
    
    public void setHash(String hash) {
        this.hash = hash;
    }

    
    @Column(name="documents_bytes")
    public Integer getDocumentsBytes() {
        return this.documentsBytes;
    }
    
    public void setDocumentsBytes(Integer documentsBytes) {
        this.documentsBytes = documentsBytes;
    }

    
    @Column(name="lock", nullable=false)
    public boolean isLock() {
        return this.lock;
    }
    
    public void setLock(boolean lock) {
        this.lock = lock;
    }

@OneToMany(fetch=FetchType.LAZY, mappedBy="predictionRequest")
    public Set<PredictionResponse> getPredictionResponses() {
        return this.predictionResponses;
    }
    
    public void setPredictionResponses(Set<PredictionResponse> predictionResponses) {
        this.predictionResponses = predictionResponses;
    }

@OneToMany(fetch=FetchType.LAZY, mappedBy="predictionRequest")
    public Set<PrivatePrediction> getPrivatePredictions() {
        return this.privatePredictions;
    }
    
    public void setPrivatePredictions(Set<PrivatePrediction> privatePredictions) {
        this.privatePredictions = privatePredictions;
    }

@OneToMany(fetch=FetchType.LAZY, mappedBy="predictionRequest")
    public Set<Prediction> getPredictions() {
        return this.predictions;
    }
    
    public void setPredictions(Set<Prediction> predictions) {
        this.predictions = predictions;
    }




}


